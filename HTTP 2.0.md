## Goals

The working group charter mentions several goals and issues of concern:

- Create a negotiation mechanism that allows clients and servers to elect to use HTTP/1.1, 2.0, or potentially other non-HTTP protocols.
- Maintain high-level compatibility with HTTP/1.1 (for example with [methods](https://en.wikipedia.org/wiki/HTTP_method "HTTP method"), [status codes](https://en.wikipedia.org/wiki/HTTP_status_code "HTTP status code"), [URIs](https://en.wikipedia.org/wiki/URI "URI"), and most [header fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields "List of HTTP header fields")).
- Decrease [latency](https://en.wikipedia.org/wiki/Latency_(engineering) "Latency (engineering)") to improve page load speed in [web browsers](https://en.wikipedia.org/wiki/Web_browser "Web browser") by considering:
    - [data compression](https://en.wikipedia.org/wiki/Data_compression "Data compression") of [HTTP headers](https://en.wikipedia.org/wiki/HTTP_header "HTTP header")
    - [HTTP/2 Server Push](https://en.wikipedia.org/wiki/HTTP/2_Server_Push "HTTP/2 Server Push")
    - prioritization of requests
    - [multiplexing](https://en.wikipedia.org/wiki/Multiplexing "Multiplexing") multiple requests over a single [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol "Transmission Control Protocol") connection (fixing the HTTP-transaction-level [head-of-line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking "Head-of-line blocking") problem in HTTPÂ 1.x) ==(In case of TCP failure the problem still exists, but on another layer)==
- Support common existing use cases of HTTP, such as desktop web browsers, mobile web browsers, web APIs, [web servers](https://en.wikipedia.org/wiki/Web_server "Web server") at various scales, [proxy servers](https://en.wikipedia.org/wiki/Proxy_server "Proxy server"), [reverse proxy](https://en.wikipedia.org/wiki/Reverse_proxy "Reverse proxy") servers, [firewalls](https://en.wikipedia.org/wiki/Firewall_(computing) "Firewall (computing)"), and [content delivery networks](https://en.wikipedia.org/wiki/Content_delivery_network "Content delivery network").

## HTTP/3 Comparison with HTTP/1.1 and HTTP/2

HTTP semantics are consistent across versions: the same [request methods](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods "Hypertext Transfer Protocol"), [status codes](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Response_status_codes "Hypertext Transfer Protocol"), and [message fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields "List of HTTP header fields") are typically applicable to all versions. The differences are in the mapping of these semantics to underlying transports. Both [HTTP/1.1](https://en.wikipedia.org/wiki/HTTP/1.1 "HTTP/1.1") and [HTTP/2](https://en.wikipedia.org/wiki/HTTP/2 "HTTP/2") use [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol "Transmission Control Protocol") as their transport. HTTP/3 uses [QUIC](https://en.wikipedia.org/wiki/QUIC "QUIC"), a [transport layer](https://en.wikipedia.org/wiki/Transport_layer "Transport layer") [network protocol](https://en.wikipedia.org/wiki/Network_protocol "Network protocol") which uses [user space](https://en.wikipedia.org/wiki/User_space "User space") [congestion control](https://en.wikipedia.org/wiki/Congestion_control "Congestion control") over the [User Datagram Protocol](https://en.wikipedia.org/wiki/User_Datagram_Protocol "User Datagram Protocol") (UDP). The switch to QUIC aims to fix a major problem of HTTP/2 called "[head-of-line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking "Head-of-line blocking")": because the parallel nature of HTTP/2's multiplexing is not visible to TCP's [loss recovery mechanisms](https://en.wikipedia.org/wiki/Packet_loss#Packet_recovery_for_reliable_delivery "Packet loss"), a lost or reordered [packet](https://en.wikipedia.org/wiki/Network_packet "Network packet") causes all active [transactions](https://en.wikipedia.org/wiki/Transaction_processing "Transaction processing") to experience a stall regardless of whether that transaction was impacted by the lost packet. Because QUIC provides native multiplexing, lost packets only impact the streams where data has been lost.